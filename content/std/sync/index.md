---
date: 2019-03-05T07:00:00+08:00
title: 同步
weight: 2030
description : "Rust标准库中的同步"
---

有用的同步原语。

### 同步化的需要

从概念上讲，Rust程序是指在计算机上执行的一系列操作。程序中发生事件的时间线与代码中的操作顺序是一致的。

考虑一下下面的代码，在一些全局静态变量上进行操作。

```rust
static mut A: u32 = 0;
static mut B: u32 = 0;
static mut C: u32 = 0;

fn main() {
    unsafe {
        A = 3;
        B = 4;
        A = A + B;
        C = B;
        println!("{} {} {}", A, B, C);
        C = A;
    }
}
```

看起来好像是改变了一些存储在内存中的变量，进行了一次加法，结果存储在A中，变量C被修改了两次。

当只涉及到一个线程时，结果和预期的一样：7 4 4 4行被打印出来。

至于幕后会发生什么，当启用优化后，最终生成的机器代码可能会和代码中的样子大不相同。

- 第一个存储到C的存储可能会被移到A或B之前，就像我们写的C = 4; A = 3; B = 4一样。

- A+B的赋值可能会被删除，因为和可以存储在一个临时位置，直到它被打印出来，而全局变量永远不会被更新。

- 最终的结果可以通过在编译时查看代码来确定，所以恒定折叠可能会把整个代码块变成一个简单的println!("7 4 4 4")。

编译器可以执行这些优化的任意组合，只要最终优化后的代码在执行时，产生的结果与没有优化的代码相同。

由于现代计算机的并发性，对程序执行顺序的假设往往是错误的。对全局变量的访问可能会导致非确定性的结果，即使是在编译器优化被禁用的情况下，仍然有可能引入同步bug。

需要注意的是，由于Rust的安全保证，访问全局（静态）变量需要不安全的代码，假设我们没有使用本模块中的任何同步基元，那么访问全局（静态）变量就需要不安全的代码。

### 结构体


- Arc：线程安全的引用计数指针。Arc 代表 "Atomically Reference Counted/原子引用计数"。
- Barrier：使多个线程能够同步某些计算的开始的屏障。
- BarrierWaitResult 一个BarrierWaitResult，当Barrier中的所有线程会合后，由wait返回。
- Condvar A条件变量
- Mutex 一个有用的相互排斥基元，用于保护共享数据。
- MutexGuard 一个RAII实现的mutex的 "范围锁"。当这个结构被丢弃（脱离范围）时，该锁将被解锁。
- Once 一个同步基元，可用于运行一次性全局初始化。适用于FFI或相关功能的一次性初始化。这个类型只能用 Once:::new 构造函数来构造。
- PoisonError 一种类型的错误，每当获得一个锁时都会返回。
- RwLock 一个读写器锁
- RwLockReadGuard RAII结构，用于释放锁的共享读权限。
- RwLockWriteGuard RAII结构，用于在丢弃时释放锁的独占写入权限。
- WaitTimeoutResult 一个表示条件变量上的定时等待是否因超时而返回的类型。
- Weak是Arc的一个版本，它持有一个非拥有者对被管理分配的引用。通过在Weak指针上调用升级，返回一个Option<Arc<T>>，即可访问该分配。
- OnceState 实验状态(ExperimentalState)屈服于call_once_force的封闭参数。该状态可以用来查询W Once的毒状态。